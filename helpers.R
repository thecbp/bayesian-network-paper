library(tidyverse)
library(bnlearn)
library(abn)
library(buildmer)
library(lme4)
library(parallel)
source("code/scutari.R")

# Initialize a cluster to parallelize some operations
ncores = detectCores()
cl = makeCluster(ncores)

# Scutari parameters:
# - number of nodes
# - average number of parents
# - number of people in dataset

# things im interested in
# performance with different numbers of random effects (none to all)


# metrics
# structure recovery (meabn, abn, me)
# parameter recovery

generate_abn_data = function(n.subj, N, prop.gauss, avg.parents,
                             prop.pos.fixef, seed, samp.size) {
  
  # N: number of nodes in the network
  # prop.gauss: proportion of nodes that are Gaussian
  # avg.parents: average number of parents for a node in the ABN
  # fixef: population level effect
  # ranef.sd: variance of individual level deviation
  # noise: within-person variance
  
  
  nodes = paste0("X", 1:N)
  n.gauss = floor(N * prop.gauss)
  gauss.nodes = sample(nodes, size = n.gauss, replace = F)
  
  dists = list()
  for (node in nodes) {
    
    if (node %in% gauss.nodes) { dists[[node]] = "gaussian" }
    else { dists[[node]] = "binomial" }
    
  }
  
  # Reordering the names alphabetically because it matters in abn
  # this is the order they will be generated by simulateAbn()
  dists = dists[order(names(dists))]
  
  # calculate needed edge density
  p = (2 * avg.parents) / N
  
  
  # Generate a DAG for a given set of parameters
  # Everyone will have the same structure, but different parameters
  dag = simulateDag(node.name = nodes, 
                    data.dists = dists, 
                    edge.density = p)
  
  fixef = sample(c(-2, 2), size = N, replace = T, 
                 prob = c(1 - prop.pos.fixef, prop.pos.fixef))
  
  data = list()
  params = list()
  
  # Generate parameters + data for each individual
  for (j in 1:n.subj) {
    
    # Generate model parameters based off mixed-effect model
    individual_params = matrix(0, nrow = N, ncol = N)
    noise = rchisq(N, df = 1)
    
    for (row in 1:N) {
      individual_params[row,] = MASS::mvrnorm(n = 1, 
                                   mu = fixef + rnorm(N, mean = 0, sd = 1),
                                   Sigma = noise * diag(N))
    }
    
    # mask the parameters using the DAG
    individual_params = individual_params * dag$dag
    
    # Generate data from the resulting data
    individual_data = simulateAbn(data.dists = dists, 
                                  data.param = individual_params,
                                  n.iter = samp.size * 10) # adjusting for the thinning of 100
    
    # Add identifier to data
    individual_data[["G"]] = j
    
    # append data 
    data[[j]] = individual_data
    params[[j]] = individual_params
    
  }
  
  # Process the data to be one unified dataset + id identifier
  full_data = bind_rows(data) %>% as.data.frame()
  
  for (node in nodes) { 
    
    if (dists[[node]] == "binomial") { full_data[[node]] = factor(full_data[[node]], levels = c(0, 1)) }
  
  }
  
  full_data$G = as.factor(full_data$G)
  
  out = list()
  out[["data"]] = full_data
  out[["dag"]] = dag$dag
  out[["dists"]] = dists
  out[["params"]] = params
  out[["sigma"]] = noise
  
  out
  
}

formula_one = function(outcome, nodes) {
   
  predictors = setdiff(nodes, c(outcome, "G"))
  fixef = paste(c(1, predictors), collapse = " + ")
  ranef = paste("+ (", fixef, "|G)")
  
  as.formula(paste(outcome, "~", fixef, ranef))
  
}

build_stepwise_models = function(data, dists, direction) {
  
  features = setdiff(names(data), "G")
  models = list()
  
  for (feature in features) {
    
    f = formula_one(feature, features)
    
    if (dists[[feature]] == "gaussian") {
      
      
      model = buildmer(formula = f, 
                       data = data,
                       family = "gaussian",
                       buildmerControl = buildmerControl(
                         direction = c("order", direction),
                         # quiet = T,
                         cl = cl)
                       )
      
      models[[feature]] = model
      
    }
    
    if (dists[[feature]] == "binomial") {
      
      model = buildmer(formula = f, 
                       data = data,
                       family = "binomial",
                       buildmerControl = buildmerControl(
                         direction = c("order", direction),
                         quiet = T,
                         cl = cl
                         )
                       )
      
      models[[feature]] = model
      
    }
    
  }
  
  # Construct an adjacency matrix 
  ## need to adjust for binomial features
  adjmat.names = c("(Intercept)")
  
  for (feature in names(dists)) {
    if (dists[[feature]] == "gaussian") { adjmat.names = c(adjmat.names, feature) }
    if (dists[[feature]] == "binomial") { adjmat.names = c(adjmat.names, paste0(feature, "1")) }
  }
  
  adjmat = matrix(0, ncol = length(names(dists)) + 1, nrow = length(names(dists)) + 1)
  colnames(adjmat) = adjmat.names
  rownames(adjmat) = c("(Intercept)", names(dists))
  
  # Get the chosen coefficients from each model
  for (m in names(models)) {
    
    # Check for if model has random effects
    if ("lmerModLmerTest" %in% class(models[[m]]@model)) {
      
      selected = rownames(models[[m]]@summary[["coefficients"]]) # accessing features of lmerTest
      adjmat[m, selected] = 1
      
    }
    
    # No random effects were found
    if ("lm" %in% class(models[[m]]@model) || "glm" %in% class(models[[m]]@model)) {
      
      selected = names(models[[m]]@model[["coefficients"]]) # accessing features of glm
      adjmat[m, selected] = 1
      
    }
    
  }
  
  # Reorder the adjacency matrix 
  adjmat = adjmat[-1, -1]
  colnames(adjmat) = names(dists)
  
  out = list()
  out[["models"]] = models
  out[["adjmat"]] = adjmat

  out
  
}

bn2adjmat = function(bn) {
  # Convert a bnlearn-object to an adjacency matrix
  
  edges = arcs(bn) %>% as.data.frame() %>% filter(from != "G", to != "G")
  nodes = setdiff(names(bn$nodes), "G")
  
  adjmat = matrix(0, nrow = length(nodes), ncol = length(nodes))
  rownames(adjmat) = nodes
  colnames(adjmat) = nodes
  
  for (i in 1:nrow(edges)) { adjmat[edges$to[i], edges$from[i]] = 1 }
  
  adjmat
  
}

simulation_suite = function(sim) {
  
  # MODEL CREATION
  
  # Run the stepwise first since these have been demonstrated to throw an error
  # Do stepwise selection for all variables
  time = lubridate::now()
  bw = build_stepwise_models(sim$data, sim$dists, "backward")
  print(paste0("Backward selection started at: ", time, " and took ", lubridate::now() - time))
  
  time = lubridate::now()
  fw = build_stepwise_models(sim$data, sim$dists, "forward")
  print(paste0("Forward selection started at: ", time, " and took ", lubridate::now() - time))
  
  # Construct a naive BN
  time = lubridate::now()
  naive.bn = hc(sim$data, maxp = 5)
  print(paste0("Naive network started at: ", time, " and took ", lubridate::now() - time))
  
  # Construct a mixed BN
  time = lubridate::now()
  me.bn = hc(sim$data, score = "custom", fun = scoreME, args = list(group = "G"), maxp = 5)
  print(paste0("ME network started at: ", time, " and took ", lubridate::now() - time))
  
  # Retrieve DAGs from the naive and mixed-effects BN
  naive.dag = bn2adjmat(naive.bn)
  me.dag = bn2adjmat(me.bn)
  
  
  # Metric calculations
  
  # missing edges: 
  # correct edge = 0, only in predicted = -1, only in truth = 1
  naive.missing.edges = sum((sim$dag - naive.dag) == 1)
  me.missing.edges = sum((sim$dag - me.dag) == 1)
  bw.missing.edges = sum((sim$dag - bw$adjmat) == 1)
  fw.missing.edges = sum((sim$dag - fw$adjmat) == 1)
  
  # extra edges
  naive.extra.edges = sum((sim$dag - naive.dag) == -1)
  me.extra.edges = sum((sim$dag - me.dag) == -1)
  bw.extra.edges = sum((sim$dag - bw$adjmat) == -1)
  fw.extra.edges = sum((sim$dag - fw$adjmat) == -1)
  
  # correct edges, but flipped
  naive.matchflip.edges = sum(sim$dag * t(naive.dag))
  me.matchflip.edges = sum(sim$dag * t(me.dag))
  bw.matchflip.edges = sum(sim$dag * t(bw$adjmat))
  fw.matchflip.edges = sum(sim$dag * t(fw$adjmat))
  
  # correct edge + orientation correct
  naive.matched.edges = sum(sim$dag * naive.dag)
  me.matched.edges = sum(sim$dag * me.dag)
  bw.matched.edges = sum(sim$dag * bw$adjmat)
  fw.matched.edges = sum(sim$dag * fw$adjmat)
  
  # hamming distance: 
  naive.hamming = naive.missing.edges + naive.extra.edges + naive.matchflip.edges 
  me.hamming = me.missing.edges + me.extra.edges + me.matchflip.edges 
  bw.hamming = bw.missing.edges + bw.extra.edges + bw.matchflip.edges 
  fw.hamming = fw.missing.edges + fw.extra.edges + fw.matchflip.edges 
  
  
  out = list()
  out[["simulation"]] = sim
  out[["true.dag"]] = sim$dag
  out[["naive_bn"]] = naive.bn
  out[["me_bn"]] = me.bn
  out[["backward"]] = bw
  out[["forward"]] = fw
  
  out[["naive.missing.edges"]] = naive.missing.edges
  out[["me.missing.edges"]] = me.missing.edges
  out[["bw.missing.edges"]] = bw.missing.edges
  out[["fw.missing.edges"]] = fw.missing.edges
  
  out[["naive.extra.edges"]] = naive.extra.edges
  out[["me.extra.edges"]] = me.extra.edges
  out[["bw.extra.edges"]] = bw.extra.edges
  out[["fw.extra.edges"]] = fw.extra.edges
  
  out[["naive.matchflip.edges"]] = naive.matchflip.edges
  out[["me.matchflip.edges"]] = me.matchflip.edges
  out[["bw.matchflip.edges"]] = bw.matchflip.edges
  out[["fw.matchflip.edges"]] = fw.matchflip.edges
  
  out[["naive.matched.edges"]] = naive.matched.edges
  out[["me.matched.edges"]] = me.matched.edges
  out[["bw.matched.edges"]] = bw.matched.edges
  out[["fw.matched.edges"]] = fw.matched.edges
  
  out[["naive.hamming"]] = naive.hamming
  out[["me.hamming"]] = me.hamming
  out[["bw.hamming"]] = bw.hamming
  out[["fw.hamming"]] = fw.hamming
  
  out
}